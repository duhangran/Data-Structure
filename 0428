01-复杂度1 最大子列和问题
给定K个整数组成的序列{ N1, N2, ..., NK }，“连续子列”被定义为{ Ni, Ni+1, ..., Nj }，其中 1≤i≤j≤K。“最大子列和”则
被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。
现要求你编写程序，计算给定整数序列的最大子列和。

本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：

数据1：与样例等价，测试基本正确性；
数据2：102个随机整数；
数据3：103个随机整数；
数据4：104个随机整数；
数据5：105个随机整数；
输入格式:
输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。

输出格式:
在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。

输入样例:
6
-2 11 -4 13 -5 -2
输出样例:
20
思路分析：（在线求解法）
思想：每扫描到一个元素，就求出和ThisSum，然后进行判断，如果ThisSum大于MaxSum，就更新MaxSum=ThisSum；
如果ThisSum小于0，就直接令ThisSum=0；重复上述步骤，直到扫描完数组的所有元素，返回MaxSum。


#include <stdio.h>
int main(){
    int a[100000],n;
    int MaxSum,ThisSum;
    int i;
    MaxSum=0;
    ThisSum=0;
    scanf("%d",&n);
    //循环输入数据
    for(i=0;i<n;i++){
        scanf("%d",&a[i]);
    }
    //函数主体，一层循环
    //时间复杂度仅为T(n)=O(n)，所以这个算法以及非常快了，但有优点就有缺点，缺点就是它容易出错。
    for(i=0;i<n;i++){
        ThisSum+=a[i];
        if(ThisSum>MaxSum){
            MaxSum = ThisSum;
        }
        else if (ThisSum<0){
            ThisSum = 0;
        }
    }
    printf("%d",MaxSum);
    return 0;
}
